// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: business_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Language, languageFromJSON, languageToJSON } from "./api";
import {
  CollectionWithoutBooks,
  DetailedBookWithDetailedChapters,
  DetailedCollection,
  DetailedHadith,
  HadithReferenceType,
  SimpleHadith,
} from "./business_models";

export const protobufPackage = "sunnahcom.hadith.api.v1";

/** 1. GetAllLanguages */
export interface GetAllLanguagesRequest {
}

export interface GetAllLanguagesResponse {
  languages: Language[];
}

/** 2. GetAllCollections */
export interface GetAllCollectionsRequest {
  /** Language for translated names */
  language: Language;
}

export interface GetAllCollectionsResponse {
  collections: CollectionWithoutBooks[];
}

/** 3. GetAllReferenceTypes */
export interface GetAllReferenceTypesRequest {
}

export interface GetAllReferenceTypesResponse {
  referenceTypes: HadithReferenceType[];
}

/** 4. GetCollectionById */
export interface GetCollectionByIdRequest {
  collectionId: string;
  /** Language for translations */
  language: Language;
}

export interface GetCollectionByIdResponse {
  collection: DetailedCollection | undefined;
}

/** 5. GetBookWithDetailedChapters */
export interface GetBookWithDetailedChaptersRequest {
  bookId: string;
  /** Language for translations */
  language: Language;
}

export interface GetBookWithDetailedChaptersResponse {
  book: DetailedBookWithDetailedChapters | undefined;
}

/** 6. GetHadith */
export interface GetHadithRequest {
  /** Language for translations */
  language: Language;
  hadithId?: string | undefined;
  reference?: HadithReferenceIdentifier | undefined;
}

export interface HadithReferenceIdentifier {
  /** e.g., "Overall", "InBook" (Corresponds to HadithReferenceType.id) */
  referenceTypeId: string;
  /** e.g., "135", "Book 4, Hadith 1" (Corresponds to HadithReferenceValue.value) */
  referenceValue: string;
}

export interface GetHadithResponse {
  hadith:
    | DetailedHadith
    | undefined;
  /** Optional: Previous hadith in sequence */
  previousHadith:
    | SimpleHadith
    | undefined;
  /** Optional: Next hadith in sequence */
  nextHadith: SimpleHadith | undefined;
}

function createBaseGetAllLanguagesRequest(): GetAllLanguagesRequest {
  return {};
}

export const GetAllLanguagesRequest: MessageFns<GetAllLanguagesRequest> = {
  encode(_: GetAllLanguagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllLanguagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllLanguagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllLanguagesRequest {
    return {};
  },

  toJSON(_: GetAllLanguagesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllLanguagesRequest>, I>>(base?: I): GetAllLanguagesRequest {
    return GetAllLanguagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllLanguagesRequest>, I>>(_: I): GetAllLanguagesRequest {
    const message = createBaseGetAllLanguagesRequest();
    return message;
  },
};

function createBaseGetAllLanguagesResponse(): GetAllLanguagesResponse {
  return { languages: [] };
}

export const GetAllLanguagesResponse: MessageFns<GetAllLanguagesResponse> = {
  encode(message: GetAllLanguagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.languages) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllLanguagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllLanguagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.languages.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.languages.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllLanguagesResponse {
    return {
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => languageFromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllLanguagesResponse): unknown {
    const obj: any = {};
    if (message.languages?.length) {
      obj.languages = message.languages.map((e) => languageToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllLanguagesResponse>, I>>(base?: I): GetAllLanguagesResponse {
    return GetAllLanguagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllLanguagesResponse>, I>>(object: I): GetAllLanguagesResponse {
    const message = createBaseGetAllLanguagesResponse();
    message.languages = object.languages?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAllCollectionsRequest(): GetAllCollectionsRequest {
  return { language: 0 };
}

export const GetAllCollectionsRequest: MessageFns<GetAllCollectionsRequest> = {
  encode(message: GetAllCollectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== 0) {
      writer.uint32(8).int32(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllCollectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllCollectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllCollectionsRequest {
    return { language: isSet(object.language) ? languageFromJSON(object.language) : 0 };
  },

  toJSON(message: GetAllCollectionsRequest): unknown {
    const obj: any = {};
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllCollectionsRequest>, I>>(base?: I): GetAllCollectionsRequest {
    return GetAllCollectionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllCollectionsRequest>, I>>(object: I): GetAllCollectionsRequest {
    const message = createBaseGetAllCollectionsRequest();
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseGetAllCollectionsResponse(): GetAllCollectionsResponse {
  return { collections: [] };
}

export const GetAllCollectionsResponse: MessageFns<GetAllCollectionsResponse> = {
  encode(message: GetAllCollectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.collections) {
      CollectionWithoutBooks.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllCollectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllCollectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collections.push(CollectionWithoutBooks.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllCollectionsResponse {
    return {
      collections: globalThis.Array.isArray(object?.collections)
        ? object.collections.map((e: any) => CollectionWithoutBooks.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllCollectionsResponse): unknown {
    const obj: any = {};
    if (message.collections?.length) {
      obj.collections = message.collections.map((e) => CollectionWithoutBooks.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllCollectionsResponse>, I>>(base?: I): GetAllCollectionsResponse {
    return GetAllCollectionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllCollectionsResponse>, I>>(object: I): GetAllCollectionsResponse {
    const message = createBaseGetAllCollectionsResponse();
    message.collections = object.collections?.map((e) => CollectionWithoutBooks.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAllReferenceTypesRequest(): GetAllReferenceTypesRequest {
  return {};
}

export const GetAllReferenceTypesRequest: MessageFns<GetAllReferenceTypesRequest> = {
  encode(_: GetAllReferenceTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllReferenceTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllReferenceTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAllReferenceTypesRequest {
    return {};
  },

  toJSON(_: GetAllReferenceTypesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllReferenceTypesRequest>, I>>(base?: I): GetAllReferenceTypesRequest {
    return GetAllReferenceTypesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllReferenceTypesRequest>, I>>(_: I): GetAllReferenceTypesRequest {
    const message = createBaseGetAllReferenceTypesRequest();
    return message;
  },
};

function createBaseGetAllReferenceTypesResponse(): GetAllReferenceTypesResponse {
  return { referenceTypes: [] };
}

export const GetAllReferenceTypesResponse: MessageFns<GetAllReferenceTypesResponse> = {
  encode(message: GetAllReferenceTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.referenceTypes) {
      HadithReferenceType.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllReferenceTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllReferenceTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceTypes.push(HadithReferenceType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllReferenceTypesResponse {
    return {
      referenceTypes: globalThis.Array.isArray(object?.referenceTypes)
        ? object.referenceTypes.map((e: any) => HadithReferenceType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAllReferenceTypesResponse): unknown {
    const obj: any = {};
    if (message.referenceTypes?.length) {
      obj.referenceTypes = message.referenceTypes.map((e) => HadithReferenceType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllReferenceTypesResponse>, I>>(base?: I): GetAllReferenceTypesResponse {
    return GetAllReferenceTypesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllReferenceTypesResponse>, I>>(object: I): GetAllReferenceTypesResponse {
    const message = createBaseGetAllReferenceTypesResponse();
    message.referenceTypes = object.referenceTypes?.map((e) => HadithReferenceType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetCollectionByIdRequest(): GetCollectionByIdRequest {
  return { collectionId: "", language: 0 };
}

export const GetCollectionByIdRequest: MessageFns<GetCollectionByIdRequest> = {
  encode(message: GetCollectionByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collectionId !== "") {
      writer.uint32(10).string(message.collectionId);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectionByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectionByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectionByIdRequest {
    return {
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
    };
  },

  toJSON(message: GetCollectionByIdRequest): unknown {
    const obj: any = {};
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCollectionByIdRequest>, I>>(base?: I): GetCollectionByIdRequest {
    return GetCollectionByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCollectionByIdRequest>, I>>(object: I): GetCollectionByIdRequest {
    const message = createBaseGetCollectionByIdRequest();
    message.collectionId = object.collectionId ?? "";
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseGetCollectionByIdResponse(): GetCollectionByIdResponse {
  return { collection: undefined };
}

export const GetCollectionByIdResponse: MessageFns<GetCollectionByIdResponse> = {
  encode(message: GetCollectionByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collection !== undefined) {
      DetailedCollection.encode(message.collection, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCollectionByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCollectionByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.collection = DetailedCollection.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCollectionByIdResponse {
    return { collection: isSet(object.collection) ? DetailedCollection.fromJSON(object.collection) : undefined };
  },

  toJSON(message: GetCollectionByIdResponse): unknown {
    const obj: any = {};
    if (message.collection !== undefined) {
      obj.collection = DetailedCollection.toJSON(message.collection);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCollectionByIdResponse>, I>>(base?: I): GetCollectionByIdResponse {
    return GetCollectionByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCollectionByIdResponse>, I>>(object: I): GetCollectionByIdResponse {
    const message = createBaseGetCollectionByIdResponse();
    message.collection = (object.collection !== undefined && object.collection !== null)
      ? DetailedCollection.fromPartial(object.collection)
      : undefined;
    return message;
  },
};

function createBaseGetBookWithDetailedChaptersRequest(): GetBookWithDetailedChaptersRequest {
  return { bookId: "", language: 0 };
}

export const GetBookWithDetailedChaptersRequest: MessageFns<GetBookWithDetailedChaptersRequest> = {
  encode(message: GetBookWithDetailedChaptersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bookId !== "") {
      writer.uint32(10).string(message.bookId);
    }
    if (message.language !== 0) {
      writer.uint32(16).int32(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBookWithDetailedChaptersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookWithDetailedChaptersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bookId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBookWithDetailedChaptersRequest {
    return {
      bookId: isSet(object.bookId) ? globalThis.String(object.bookId) : "",
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
    };
  },

  toJSON(message: GetBookWithDetailedChaptersRequest): unknown {
    const obj: any = {};
    if (message.bookId !== "") {
      obj.bookId = message.bookId;
    }
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBookWithDetailedChaptersRequest>, I>>(
    base?: I,
  ): GetBookWithDetailedChaptersRequest {
    return GetBookWithDetailedChaptersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBookWithDetailedChaptersRequest>, I>>(
    object: I,
  ): GetBookWithDetailedChaptersRequest {
    const message = createBaseGetBookWithDetailedChaptersRequest();
    message.bookId = object.bookId ?? "";
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseGetBookWithDetailedChaptersResponse(): GetBookWithDetailedChaptersResponse {
  return { book: undefined };
}

export const GetBookWithDetailedChaptersResponse: MessageFns<GetBookWithDetailedChaptersResponse> = {
  encode(message: GetBookWithDetailedChaptersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.book !== undefined) {
      DetailedBookWithDetailedChapters.encode(message.book, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBookWithDetailedChaptersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBookWithDetailedChaptersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.book = DetailedBookWithDetailedChapters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBookWithDetailedChaptersResponse {
    return { book: isSet(object.book) ? DetailedBookWithDetailedChapters.fromJSON(object.book) : undefined };
  },

  toJSON(message: GetBookWithDetailedChaptersResponse): unknown {
    const obj: any = {};
    if (message.book !== undefined) {
      obj.book = DetailedBookWithDetailedChapters.toJSON(message.book);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetBookWithDetailedChaptersResponse>, I>>(
    base?: I,
  ): GetBookWithDetailedChaptersResponse {
    return GetBookWithDetailedChaptersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetBookWithDetailedChaptersResponse>, I>>(
    object: I,
  ): GetBookWithDetailedChaptersResponse {
    const message = createBaseGetBookWithDetailedChaptersResponse();
    message.book = (object.book !== undefined && object.book !== null)
      ? DetailedBookWithDetailedChapters.fromPartial(object.book)
      : undefined;
    return message;
  },
};

function createBaseGetHadithRequest(): GetHadithRequest {
  return { language: 0, hadithId: undefined, reference: undefined };
}

export const GetHadithRequest: MessageFns<GetHadithRequest> = {
  encode(message: GetHadithRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.language !== 0) {
      writer.uint32(8).int32(message.language);
    }
    if (message.hadithId !== undefined) {
      writer.uint32(18).string(message.hadithId);
    }
    if (message.reference !== undefined) {
      HadithReferenceIdentifier.encode(message.reference, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHadithRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHadithRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hadithId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reference = HadithReferenceIdentifier.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHadithRequest {
    return {
      language: isSet(object.language) ? languageFromJSON(object.language) : 0,
      hadithId: isSet(object.hadithId) ? globalThis.String(object.hadithId) : undefined,
      reference: isSet(object.reference) ? HadithReferenceIdentifier.fromJSON(object.reference) : undefined,
    };
  },

  toJSON(message: GetHadithRequest): unknown {
    const obj: any = {};
    if (message.language !== 0) {
      obj.language = languageToJSON(message.language);
    }
    if (message.hadithId !== undefined) {
      obj.hadithId = message.hadithId;
    }
    if (message.reference !== undefined) {
      obj.reference = HadithReferenceIdentifier.toJSON(message.reference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHadithRequest>, I>>(base?: I): GetHadithRequest {
    return GetHadithRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHadithRequest>, I>>(object: I): GetHadithRequest {
    const message = createBaseGetHadithRequest();
    message.language = object.language ?? 0;
    message.hadithId = object.hadithId ?? undefined;
    message.reference = (object.reference !== undefined && object.reference !== null)
      ? HadithReferenceIdentifier.fromPartial(object.reference)
      : undefined;
    return message;
  },
};

function createBaseHadithReferenceIdentifier(): HadithReferenceIdentifier {
  return { referenceTypeId: "", referenceValue: "" };
}

export const HadithReferenceIdentifier: MessageFns<HadithReferenceIdentifier> = {
  encode(message: HadithReferenceIdentifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceTypeId !== "") {
      writer.uint32(10).string(message.referenceTypeId);
    }
    if (message.referenceValue !== "") {
      writer.uint32(18).string(message.referenceValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HadithReferenceIdentifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHadithReferenceIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceTypeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.referenceValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HadithReferenceIdentifier {
    return {
      referenceTypeId: isSet(object.referenceTypeId) ? globalThis.String(object.referenceTypeId) : "",
      referenceValue: isSet(object.referenceValue) ? globalThis.String(object.referenceValue) : "",
    };
  },

  toJSON(message: HadithReferenceIdentifier): unknown {
    const obj: any = {};
    if (message.referenceTypeId !== "") {
      obj.referenceTypeId = message.referenceTypeId;
    }
    if (message.referenceValue !== "") {
      obj.referenceValue = message.referenceValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HadithReferenceIdentifier>, I>>(base?: I): HadithReferenceIdentifier {
    return HadithReferenceIdentifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HadithReferenceIdentifier>, I>>(object: I): HadithReferenceIdentifier {
    const message = createBaseHadithReferenceIdentifier();
    message.referenceTypeId = object.referenceTypeId ?? "";
    message.referenceValue = object.referenceValue ?? "";
    return message;
  },
};

function createBaseGetHadithResponse(): GetHadithResponse {
  return { hadith: undefined, previousHadith: undefined, nextHadith: undefined };
}

export const GetHadithResponse: MessageFns<GetHadithResponse> = {
  encode(message: GetHadithResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hadith !== undefined) {
      DetailedHadith.encode(message.hadith, writer.uint32(10).fork()).join();
    }
    if (message.previousHadith !== undefined) {
      SimpleHadith.encode(message.previousHadith, writer.uint32(18).fork()).join();
    }
    if (message.nextHadith !== undefined) {
      SimpleHadith.encode(message.nextHadith, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHadithResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHadithResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hadith = DetailedHadith.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousHadith = SimpleHadith.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nextHadith = SimpleHadith.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHadithResponse {
    return {
      hadith: isSet(object.hadith) ? DetailedHadith.fromJSON(object.hadith) : undefined,
      previousHadith: isSet(object.previousHadith) ? SimpleHadith.fromJSON(object.previousHadith) : undefined,
      nextHadith: isSet(object.nextHadith) ? SimpleHadith.fromJSON(object.nextHadith) : undefined,
    };
  },

  toJSON(message: GetHadithResponse): unknown {
    const obj: any = {};
    if (message.hadith !== undefined) {
      obj.hadith = DetailedHadith.toJSON(message.hadith);
    }
    if (message.previousHadith !== undefined) {
      obj.previousHadith = SimpleHadith.toJSON(message.previousHadith);
    }
    if (message.nextHadith !== undefined) {
      obj.nextHadith = SimpleHadith.toJSON(message.nextHadith);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHadithResponse>, I>>(base?: I): GetHadithResponse {
    return GetHadithResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHadithResponse>, I>>(object: I): GetHadithResponse {
    const message = createBaseGetHadithResponse();
    message.hadith = (object.hadith !== undefined && object.hadith !== null)
      ? DetailedHadith.fromPartial(object.hadith)
      : undefined;
    message.previousHadith = (object.previousHadith !== undefined && object.previousHadith !== null)
      ? SimpleHadith.fromPartial(object.previousHadith)
      : undefined;
    message.nextHadith = (object.nextHadith !== undefined && object.nextHadith !== null)
      ? SimpleHadith.fromPartial(object.nextHadith)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
