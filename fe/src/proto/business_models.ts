// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: business_models.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "sunnahcom.hadith.v1";

/** CollectionType defines the types of collections in the system */
export enum CollectionType {
  UNSPECIFIED = 0,
  /** COLLECTION - A standard collection like Sahih Bukhari */
  COLLECTION = 1,
  /** SELECTION - A curated selection of hadiths */
  SELECTION = 2,
  UNRECOGNIZED = -1,
}

export function collectionTypeFromJSON(object: any): CollectionType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return CollectionType.UNSPECIFIED;
    case 1:
    case "COLLECTION":
      return CollectionType.COLLECTION;
    case 2:
    case "SELECTION":
      return CollectionType.SELECTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CollectionType.UNRECOGNIZED;
  }
}

export function collectionTypeToJSON(object: CollectionType): string {
  switch (object) {
    case CollectionType.UNSPECIFIED:
      return "UNSPECIFIED";
    case CollectionType.COLLECTION:
      return "COLLECTION";
    case CollectionType.SELECTION:
      return "SELECTION";
    case CollectionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TranslationStatus indicates the progress of translation efforts for a collection or entity */
export enum TranslationStatus {
  TRANSLATION_STATUS_UNSPECIFIED = 0,
  /** TRANSLATION_STATUS_PENDING - Not started */
  TRANSLATION_STATUS_PENDING = 1,
  /** TRANSLATION_STATUS_IN_PROGRESS - Partially translated */
  TRANSLATION_STATUS_IN_PROGRESS = 2,
  /** TRANSLATION_STATUS_COMPLETED - Fully translated */
  TRANSLATION_STATUS_COMPLETED = 3,
  UNRECOGNIZED = -1,
}

export function translationStatusFromJSON(object: any): TranslationStatus {
  switch (object) {
    case 0:
    case "TRANSLATION_STATUS_UNSPECIFIED":
      return TranslationStatus.TRANSLATION_STATUS_UNSPECIFIED;
    case 1:
    case "TRANSLATION_STATUS_PENDING":
      return TranslationStatus.TRANSLATION_STATUS_PENDING;
    case 2:
    case "TRANSLATION_STATUS_IN_PROGRESS":
      return TranslationStatus.TRANSLATION_STATUS_IN_PROGRESS;
    case 3:
    case "TRANSLATION_STATUS_COMPLETED":
      return TranslationStatus.TRANSLATION_STATUS_COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TranslationStatus.UNRECOGNIZED;
  }
}

export function translationStatusToJSON(object: TranslationStatus): string {
  switch (object) {
    case TranslationStatus.TRANSLATION_STATUS_UNSPECIFIED:
      return "TRANSLATION_STATUS_UNSPECIFIED";
    case TranslationStatus.TRANSLATION_STATUS_PENDING:
      return "TRANSLATION_STATUS_PENDING";
    case TranslationStatus.TRANSLATION_STATUS_IN_PROGRESS:
      return "TRANSLATION_STATUS_IN_PROGRESS";
    case TranslationStatus.TRANSLATION_STATUS_COMPLETED:
      return "TRANSLATION_STATUS_COMPLETED";
    case TranslationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** HadithReferenceValue stores different reference numbering systems for a single Hadith. */
export interface HadithReferenceValue {
  /** Name of the reference system */
  id: string;
  /** The actual reference string (e.g., "135", "Book 4, Hadith 1") */
  value: string;
}

export interface HadithReferenceType {
  /** Name of the reference system */
  id: string;
  /** Display name of the reference system */
  name: string;
  /** Priority for sorting */
  priority: number;
}

/** HadithGrader represents an entity that provides grades for hadiths. */
export interface HadithGrader {
  id: string;
  /** Translated name in the requested language */
  translatedName: string;
}

/** HadithGrading links a Hadith to its grade from a specific Grader. */
export interface HadithGrading {
  /** The grader who provided the grade */
  grader:
    | HadithGrader
    | undefined;
  /** The grade value (e.g., "Sahih", "Hasan") */
  grade: string;
}

/** CollectionWithoutBooks contains minimal information for listing/reference. */
export interface CollectionWithoutBooks {
  id: string;
  /** Original name (typically Arabic) */
  title: string;
  /** Translated name in the requested language */
  introduction: string;
  type: CollectionType;
  /** From CollectionMeta */
  numBooks: number;
  /** From CollectionMeta */
  numHadiths: number;
  /** From CollectionMeta */
  showInBookReferences: boolean;
  /** From CollectionMeta */
  showOnHomePage: boolean;
  /** From CollectionMeta */
  translationStatus: TranslationStatus;
  /** From CollectionMeta */
  numberingDisclaimer: string;
  translatedTitle: string;
}

/** SimpleBook contains minimal information for listing/reference. */
export interface SimpleBook {
  id: string;
  /** Original title (typically Arabic) */
  title: string;
  /** Translated title in the requested language */
  translatedTitle: string;
  /** E.g., "1", "2a" */
  bookNumber: string;
  /** Order within the collection */
  order: number;
  /** Number of chapters in the book */
  numChapters: number;
  /** Number of hadiths in the book */
  numHadiths: number;
}

/** SimpleChapter contains minimal information for listing/reference. */
export interface SimpleChapter {
  id: string;
  /** Original title (typically Arabic) */
  title: string;
  /** Translated title in the requested language */
  translatedTitle: string;
  /** E.g., "1", "1a" */
  chapterNumber: string;
  /** Order within the book */
  order: number;
  /** Number of hadiths in the chapter */
  numHadiths: number;
}

/** SimpleHadith contains essential information including Arabic/translation, references, and gradings. */
export interface SimpleHadith {
  id: string;
  /** E.g., "135", "1a" */
  hadithNumber: string;
  /** Original Arabic text */
  arabicText: string;
  /** Translated text in the requested language */
  translatedText: string;
  /** Order within the chapter */
  order: number;
  /** Essential references */
  references: HadithReferenceValue[];
  /** Essential gradings */
  gradings: HadithGrading[];
}

/** DetailedCollection contains comprehensive information including nested simple books. */
export interface DetailedCollection {
  id: string;
  /** Original name (typically Arabic) */
  name: string;
  /** Translated name in the requested language */
  translatedName: string;
  type: CollectionType;
  numBooks: number;
  numHadiths: number;
  /** From CollectionMeta */
  showInBookReferences: boolean;
  /** From CollectionMeta */
  showOnHomePage: boolean;
  /** From CollectionMeta */
  translationStatus: TranslationStatus;
  /** From CollectionMeta */
  numberingDisclaimer: string;
  /** Introduction text in the requested language */
  introduction: string;
  /** List of simple books in the collection */
  books: SimpleBook[];
  /** Graders applicable to this collection */
  applicableGraders: HadithGrader[];
}

/** DetailedBook contains comprehensive information including nested simple chapters and parent collection. */
export interface DetailedBook {
  id: string;
  /** Original title (typically Arabic) */
  title: string;
  /** Translated title in the requested language */
  translatedTitle: string;
  bookNumber: string;
  order: number;
  /** ID of the parent collection */
  collectionId: string;
  /** Introduction text in the requested language */
  introduction: string;
  /** List of simple chapters in the book */
  chapters: SimpleChapter[];
  /** Number of hadiths in the book */
  numHadiths: number;
}

export interface DetailedBookWithDetailedChapters {
  id: string;
  /** Original title (typically Arabic) */
  title: string;
  /** Translated title in the requested language */
  translatedTitle: string;
  bookNumber: string;
  order: number;
  /** ID of the parent collection */
  collectionId: string;
  /** Introduction text in the requested language */
  introduction: string;
  /** List of detailed chapters in the book */
  chapters: DetailedChapter[];
  /** Number of hadiths in the book */
  numHadiths: number;
}

/** DetailedChapter contains comprehensive information including nested simple hadiths and parent book/collection. */
export interface DetailedChapter {
  id: string;
  /** Original title (typically Arabic) */
  title: string;
  /** Translated title in the requested language */
  translatedTitle: string;
  chapterNumber: string;
  order: number;
  /** Simple representation of the parent book */
  book:
    | SimpleBook
    | undefined;
  /** ID of the parent collection */
  collectionId: string;
  /** Introduction text in the requested language */
  introduction: string;
  /** List of simple hadiths in the chapter */
  hadiths: SimpleHadith[];
}

/** DetailedHadith contains comprehensive information including parent chapter/book/collection and full details. */
export interface DetailedHadith {
  id: string;
  hadithNumber: string;
  arabicText: string;
  /** Translated text in the requested language */
  translatedText: string;
  order: number;
  references: HadithReferenceValue[];
  gradings: HadithGrading[];
  /** Simple representation of the parent chapter */
  chapter:
    | SimpleChapter
    | undefined;
  /** Simple representation of the parent book */
  book:
    | SimpleBook
    | undefined;
  /** ID of the parent collection */
  collectionId: string;
  /** Explanation text in the requested language */
  explanation: string;
}

function createBaseHadithReferenceValue(): HadithReferenceValue {
  return { id: "", value: "" };
}

export const HadithReferenceValue: MessageFns<HadithReferenceValue> = {
  encode(message: HadithReferenceValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HadithReferenceValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHadithReferenceValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HadithReferenceValue {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HadithReferenceValue): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HadithReferenceValue>, I>>(base?: I): HadithReferenceValue {
    return HadithReferenceValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HadithReferenceValue>, I>>(object: I): HadithReferenceValue {
    const message = createBaseHadithReferenceValue();
    message.id = object.id ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHadithReferenceType(): HadithReferenceType {
  return { id: "", name: "", priority: 0 };
}

export const HadithReferenceType: MessageFns<HadithReferenceType> = {
  encode(message: HadithReferenceType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.priority !== 0) {
      writer.uint32(24).int32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HadithReferenceType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHadithReferenceType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HadithReferenceType {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: HadithReferenceType): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HadithReferenceType>, I>>(base?: I): HadithReferenceType {
    return HadithReferenceType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HadithReferenceType>, I>>(object: I): HadithReferenceType {
    const message = createBaseHadithReferenceType();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseHadithGrader(): HadithGrader {
  return { id: "", translatedName: "" };
}

export const HadithGrader: MessageFns<HadithGrader> = {
  encode(message: HadithGrader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.translatedName !== "") {
      writer.uint32(18).string(message.translatedName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HadithGrader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHadithGrader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.translatedName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HadithGrader {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      translatedName: isSet(object.translatedName) ? globalThis.String(object.translatedName) : "",
    };
  },

  toJSON(message: HadithGrader): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.translatedName !== "") {
      obj.translatedName = message.translatedName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HadithGrader>, I>>(base?: I): HadithGrader {
    return HadithGrader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HadithGrader>, I>>(object: I): HadithGrader {
    const message = createBaseHadithGrader();
    message.id = object.id ?? "";
    message.translatedName = object.translatedName ?? "";
    return message;
  },
};

function createBaseHadithGrading(): HadithGrading {
  return { grader: undefined, grade: "" };
}

export const HadithGrading: MessageFns<HadithGrading> = {
  encode(message: HadithGrading, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.grader !== undefined) {
      HadithGrader.encode(message.grader, writer.uint32(10).fork()).join();
    }
    if (message.grade !== "") {
      writer.uint32(18).string(message.grade);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HadithGrading {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHadithGrading();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.grader = HadithGrader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.grade = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HadithGrading {
    return {
      grader: isSet(object.grader) ? HadithGrader.fromJSON(object.grader) : undefined,
      grade: isSet(object.grade) ? globalThis.String(object.grade) : "",
    };
  },

  toJSON(message: HadithGrading): unknown {
    const obj: any = {};
    if (message.grader !== undefined) {
      obj.grader = HadithGrader.toJSON(message.grader);
    }
    if (message.grade !== "") {
      obj.grade = message.grade;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HadithGrading>, I>>(base?: I): HadithGrading {
    return HadithGrading.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HadithGrading>, I>>(object: I): HadithGrading {
    const message = createBaseHadithGrading();
    message.grader = (object.grader !== undefined && object.grader !== null)
      ? HadithGrader.fromPartial(object.grader)
      : undefined;
    message.grade = object.grade ?? "";
    return message;
  },
};

function createBaseCollectionWithoutBooks(): CollectionWithoutBooks {
  return {
    id: "",
    title: "",
    introduction: "",
    type: 0,
    numBooks: 0,
    numHadiths: 0,
    showInBookReferences: false,
    showOnHomePage: false,
    translationStatus: 0,
    numberingDisclaimer: "",
    translatedTitle: "",
  };
}

export const CollectionWithoutBooks: MessageFns<CollectionWithoutBooks> = {
  encode(message: CollectionWithoutBooks, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.introduction !== "") {
      writer.uint32(26).string(message.introduction);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.numBooks !== 0) {
      writer.uint32(40).int32(message.numBooks);
    }
    if (message.numHadiths !== 0) {
      writer.uint32(48).int32(message.numHadiths);
    }
    if (message.showInBookReferences !== false) {
      writer.uint32(56).bool(message.showInBookReferences);
    }
    if (message.showOnHomePage !== false) {
      writer.uint32(64).bool(message.showOnHomePage);
    }
    if (message.translationStatus !== 0) {
      writer.uint32(72).int32(message.translationStatus);
    }
    if (message.numberingDisclaimer !== "") {
      writer.uint32(82).string(message.numberingDisclaimer);
    }
    if (message.translatedTitle !== "") {
      writer.uint32(90).string(message.translatedTitle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollectionWithoutBooks {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollectionWithoutBooks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numBooks = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numHadiths = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.showInBookReferences = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.showOnHomePage = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.translationStatus = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.numberingDisclaimer = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.translatedTitle = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollectionWithoutBooks {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      type: isSet(object.type) ? collectionTypeFromJSON(object.type) : 0,
      numBooks: isSet(object.numBooks) ? globalThis.Number(object.numBooks) : 0,
      numHadiths: isSet(object.numHadiths) ? globalThis.Number(object.numHadiths) : 0,
      showInBookReferences: isSet(object.showInBookReferences)
        ? globalThis.Boolean(object.showInBookReferences)
        : false,
      showOnHomePage: isSet(object.showOnHomePage) ? globalThis.Boolean(object.showOnHomePage) : false,
      translationStatus: isSet(object.translationStatus) ? translationStatusFromJSON(object.translationStatus) : 0,
      numberingDisclaimer: isSet(object.numberingDisclaimer) ? globalThis.String(object.numberingDisclaimer) : "",
      translatedTitle: isSet(object.translatedTitle) ? globalThis.String(object.translatedTitle) : "",
    };
  },

  toJSON(message: CollectionWithoutBooks): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    if (message.type !== 0) {
      obj.type = collectionTypeToJSON(message.type);
    }
    if (message.numBooks !== 0) {
      obj.numBooks = Math.round(message.numBooks);
    }
    if (message.numHadiths !== 0) {
      obj.numHadiths = Math.round(message.numHadiths);
    }
    if (message.showInBookReferences !== false) {
      obj.showInBookReferences = message.showInBookReferences;
    }
    if (message.showOnHomePage !== false) {
      obj.showOnHomePage = message.showOnHomePage;
    }
    if (message.translationStatus !== 0) {
      obj.translationStatus = translationStatusToJSON(message.translationStatus);
    }
    if (message.numberingDisclaimer !== "") {
      obj.numberingDisclaimer = message.numberingDisclaimer;
    }
    if (message.translatedTitle !== "") {
      obj.translatedTitle = message.translatedTitle;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CollectionWithoutBooks>, I>>(base?: I): CollectionWithoutBooks {
    return CollectionWithoutBooks.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CollectionWithoutBooks>, I>>(object: I): CollectionWithoutBooks {
    const message = createBaseCollectionWithoutBooks();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.introduction = object.introduction ?? "";
    message.type = object.type ?? 0;
    message.numBooks = object.numBooks ?? 0;
    message.numHadiths = object.numHadiths ?? 0;
    message.showInBookReferences = object.showInBookReferences ?? false;
    message.showOnHomePage = object.showOnHomePage ?? false;
    message.translationStatus = object.translationStatus ?? 0;
    message.numberingDisclaimer = object.numberingDisclaimer ?? "";
    message.translatedTitle = object.translatedTitle ?? "";
    return message;
  },
};

function createBaseSimpleBook(): SimpleBook {
  return { id: "", title: "", translatedTitle: "", bookNumber: "", order: 0, numChapters: 0, numHadiths: 0 };
}

export const SimpleBook: MessageFns<SimpleBook> = {
  encode(message: SimpleBook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.translatedTitle !== "") {
      writer.uint32(26).string(message.translatedTitle);
    }
    if (message.bookNumber !== "") {
      writer.uint32(34).string(message.bookNumber);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    if (message.numChapters !== 0) {
      writer.uint32(48).int32(message.numChapters);
    }
    if (message.numHadiths !== 0) {
      writer.uint32(56).int32(message.numHadiths);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleBook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleBook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.translatedTitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bookNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numChapters = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.numHadiths = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleBook {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      translatedTitle: isSet(object.translatedTitle) ? globalThis.String(object.translatedTitle) : "",
      bookNumber: isSet(object.bookNumber) ? globalThis.String(object.bookNumber) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      numChapters: isSet(object.numChapters) ? globalThis.Number(object.numChapters) : 0,
      numHadiths: isSet(object.numHadiths) ? globalThis.Number(object.numHadiths) : 0,
    };
  },

  toJSON(message: SimpleBook): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.translatedTitle !== "") {
      obj.translatedTitle = message.translatedTitle;
    }
    if (message.bookNumber !== "") {
      obj.bookNumber = message.bookNumber;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.numChapters !== 0) {
      obj.numChapters = Math.round(message.numChapters);
    }
    if (message.numHadiths !== 0) {
      obj.numHadiths = Math.round(message.numHadiths);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleBook>, I>>(base?: I): SimpleBook {
    return SimpleBook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleBook>, I>>(object: I): SimpleBook {
    const message = createBaseSimpleBook();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.translatedTitle = object.translatedTitle ?? "";
    message.bookNumber = object.bookNumber ?? "";
    message.order = object.order ?? 0;
    message.numChapters = object.numChapters ?? 0;
    message.numHadiths = object.numHadiths ?? 0;
    return message;
  },
};

function createBaseSimpleChapter(): SimpleChapter {
  return { id: "", title: "", translatedTitle: "", chapterNumber: "", order: 0, numHadiths: 0 };
}

export const SimpleChapter: MessageFns<SimpleChapter> = {
  encode(message: SimpleChapter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.translatedTitle !== "") {
      writer.uint32(26).string(message.translatedTitle);
    }
    if (message.chapterNumber !== "") {
      writer.uint32(34).string(message.chapterNumber);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    if (message.numHadiths !== 0) {
      writer.uint32(48).int32(message.numHadiths);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleChapter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleChapter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.translatedTitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chapterNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numHadiths = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleChapter {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      translatedTitle: isSet(object.translatedTitle) ? globalThis.String(object.translatedTitle) : "",
      chapterNumber: isSet(object.chapterNumber) ? globalThis.String(object.chapterNumber) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      numHadiths: isSet(object.numHadiths) ? globalThis.Number(object.numHadiths) : 0,
    };
  },

  toJSON(message: SimpleChapter): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.translatedTitle !== "") {
      obj.translatedTitle = message.translatedTitle;
    }
    if (message.chapterNumber !== "") {
      obj.chapterNumber = message.chapterNumber;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.numHadiths !== 0) {
      obj.numHadiths = Math.round(message.numHadiths);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleChapter>, I>>(base?: I): SimpleChapter {
    return SimpleChapter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleChapter>, I>>(object: I): SimpleChapter {
    const message = createBaseSimpleChapter();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.translatedTitle = object.translatedTitle ?? "";
    message.chapterNumber = object.chapterNumber ?? "";
    message.order = object.order ?? 0;
    message.numHadiths = object.numHadiths ?? 0;
    return message;
  },
};

function createBaseSimpleHadith(): SimpleHadith {
  return { id: "", hadithNumber: "", arabicText: "", translatedText: "", order: 0, references: [], gradings: [] };
}

export const SimpleHadith: MessageFns<SimpleHadith> = {
  encode(message: SimpleHadith, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.hadithNumber !== "") {
      writer.uint32(18).string(message.hadithNumber);
    }
    if (message.arabicText !== "") {
      writer.uint32(26).string(message.arabicText);
    }
    if (message.translatedText !== "") {
      writer.uint32(34).string(message.translatedText);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    for (const v of message.references) {
      HadithReferenceValue.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.gradings) {
      HadithGrading.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleHadith {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleHadith();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hadithNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.arabicText = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.translatedText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.references.push(HadithReferenceValue.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gradings.push(HadithGrading.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleHadith {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      hadithNumber: isSet(object.hadithNumber) ? globalThis.String(object.hadithNumber) : "",
      arabicText: isSet(object.arabicText) ? globalThis.String(object.arabicText) : "",
      translatedText: isSet(object.translatedText) ? globalThis.String(object.translatedText) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => HadithReferenceValue.fromJSON(e))
        : [],
      gradings: globalThis.Array.isArray(object?.gradings)
        ? object.gradings.map((e: any) => HadithGrading.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SimpleHadith): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.hadithNumber !== "") {
      obj.hadithNumber = message.hadithNumber;
    }
    if (message.arabicText !== "") {
      obj.arabicText = message.arabicText;
    }
    if (message.translatedText !== "") {
      obj.translatedText = message.translatedText;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => HadithReferenceValue.toJSON(e));
    }
    if (message.gradings?.length) {
      obj.gradings = message.gradings.map((e) => HadithGrading.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleHadith>, I>>(base?: I): SimpleHadith {
    return SimpleHadith.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleHadith>, I>>(object: I): SimpleHadith {
    const message = createBaseSimpleHadith();
    message.id = object.id ?? "";
    message.hadithNumber = object.hadithNumber ?? "";
    message.arabicText = object.arabicText ?? "";
    message.translatedText = object.translatedText ?? "";
    message.order = object.order ?? 0;
    message.references = object.references?.map((e) => HadithReferenceValue.fromPartial(e)) || [];
    message.gradings = object.gradings?.map((e) => HadithGrading.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDetailedCollection(): DetailedCollection {
  return {
    id: "",
    name: "",
    translatedName: "",
    type: 0,
    numBooks: 0,
    numHadiths: 0,
    showInBookReferences: false,
    showOnHomePage: false,
    translationStatus: 0,
    numberingDisclaimer: "",
    introduction: "",
    books: [],
    applicableGraders: [],
  };
}

export const DetailedCollection: MessageFns<DetailedCollection> = {
  encode(message: DetailedCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.translatedName !== "") {
      writer.uint32(26).string(message.translatedName);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.numBooks !== 0) {
      writer.uint32(40).int32(message.numBooks);
    }
    if (message.numHadiths !== 0) {
      writer.uint32(48).int32(message.numHadiths);
    }
    if (message.showInBookReferences !== false) {
      writer.uint32(56).bool(message.showInBookReferences);
    }
    if (message.showOnHomePage !== false) {
      writer.uint32(64).bool(message.showOnHomePage);
    }
    if (message.translationStatus !== 0) {
      writer.uint32(72).int32(message.translationStatus);
    }
    if (message.numberingDisclaimer !== "") {
      writer.uint32(82).string(message.numberingDisclaimer);
    }
    if (message.introduction !== "") {
      writer.uint32(90).string(message.introduction);
    }
    for (const v of message.books) {
      SimpleBook.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.applicableGraders) {
      HadithGrader.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.translatedName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numBooks = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numHadiths = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.showInBookReferences = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.showOnHomePage = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.translationStatus = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.numberingDisclaimer = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.books.push(SimpleBook.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.applicableGraders.push(HadithGrader.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedCollection {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      translatedName: isSet(object.translatedName) ? globalThis.String(object.translatedName) : "",
      type: isSet(object.type) ? collectionTypeFromJSON(object.type) : 0,
      numBooks: isSet(object.numBooks) ? globalThis.Number(object.numBooks) : 0,
      numHadiths: isSet(object.numHadiths) ? globalThis.Number(object.numHadiths) : 0,
      showInBookReferences: isSet(object.showInBookReferences)
        ? globalThis.Boolean(object.showInBookReferences)
        : false,
      showOnHomePage: isSet(object.showOnHomePage) ? globalThis.Boolean(object.showOnHomePage) : false,
      translationStatus: isSet(object.translationStatus) ? translationStatusFromJSON(object.translationStatus) : 0,
      numberingDisclaimer: isSet(object.numberingDisclaimer) ? globalThis.String(object.numberingDisclaimer) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      books: globalThis.Array.isArray(object?.books) ? object.books.map((e: any) => SimpleBook.fromJSON(e)) : [],
      applicableGraders: globalThis.Array.isArray(object?.applicableGraders)
        ? object.applicableGraders.map((e: any) => HadithGrader.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DetailedCollection): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.translatedName !== "") {
      obj.translatedName = message.translatedName;
    }
    if (message.type !== 0) {
      obj.type = collectionTypeToJSON(message.type);
    }
    if (message.numBooks !== 0) {
      obj.numBooks = Math.round(message.numBooks);
    }
    if (message.numHadiths !== 0) {
      obj.numHadiths = Math.round(message.numHadiths);
    }
    if (message.showInBookReferences !== false) {
      obj.showInBookReferences = message.showInBookReferences;
    }
    if (message.showOnHomePage !== false) {
      obj.showOnHomePage = message.showOnHomePage;
    }
    if (message.translationStatus !== 0) {
      obj.translationStatus = translationStatusToJSON(message.translationStatus);
    }
    if (message.numberingDisclaimer !== "") {
      obj.numberingDisclaimer = message.numberingDisclaimer;
    }
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    if (message.books?.length) {
      obj.books = message.books.map((e) => SimpleBook.toJSON(e));
    }
    if (message.applicableGraders?.length) {
      obj.applicableGraders = message.applicableGraders.map((e) => HadithGrader.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailedCollection>, I>>(base?: I): DetailedCollection {
    return DetailedCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailedCollection>, I>>(object: I): DetailedCollection {
    const message = createBaseDetailedCollection();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.translatedName = object.translatedName ?? "";
    message.type = object.type ?? 0;
    message.numBooks = object.numBooks ?? 0;
    message.numHadiths = object.numHadiths ?? 0;
    message.showInBookReferences = object.showInBookReferences ?? false;
    message.showOnHomePage = object.showOnHomePage ?? false;
    message.translationStatus = object.translationStatus ?? 0;
    message.numberingDisclaimer = object.numberingDisclaimer ?? "";
    message.introduction = object.introduction ?? "";
    message.books = object.books?.map((e) => SimpleBook.fromPartial(e)) || [];
    message.applicableGraders = object.applicableGraders?.map((e) => HadithGrader.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDetailedBook(): DetailedBook {
  return {
    id: "",
    title: "",
    translatedTitle: "",
    bookNumber: "",
    order: 0,
    collectionId: "",
    introduction: "",
    chapters: [],
    numHadiths: 0,
  };
}

export const DetailedBook: MessageFns<DetailedBook> = {
  encode(message: DetailedBook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.translatedTitle !== "") {
      writer.uint32(26).string(message.translatedTitle);
    }
    if (message.bookNumber !== "") {
      writer.uint32(34).string(message.bookNumber);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    if (message.collectionId !== "") {
      writer.uint32(50).string(message.collectionId);
    }
    if (message.introduction !== "") {
      writer.uint32(58).string(message.introduction);
    }
    for (const v of message.chapters) {
      SimpleChapter.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.numHadiths !== 0) {
      writer.uint32(72).int32(message.numHadiths);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedBook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedBook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.translatedTitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bookNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.chapters.push(SimpleChapter.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.numHadiths = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedBook {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      translatedTitle: isSet(object.translatedTitle) ? globalThis.String(object.translatedTitle) : "",
      bookNumber: isSet(object.bookNumber) ? globalThis.String(object.bookNumber) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      chapters: globalThis.Array.isArray(object?.chapters)
        ? object.chapters.map((e: any) => SimpleChapter.fromJSON(e))
        : [],
      numHadiths: isSet(object.numHadiths) ? globalThis.Number(object.numHadiths) : 0,
    };
  },

  toJSON(message: DetailedBook): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.translatedTitle !== "") {
      obj.translatedTitle = message.translatedTitle;
    }
    if (message.bookNumber !== "") {
      obj.bookNumber = message.bookNumber;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    if (message.chapters?.length) {
      obj.chapters = message.chapters.map((e) => SimpleChapter.toJSON(e));
    }
    if (message.numHadiths !== 0) {
      obj.numHadiths = Math.round(message.numHadiths);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailedBook>, I>>(base?: I): DetailedBook {
    return DetailedBook.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailedBook>, I>>(object: I): DetailedBook {
    const message = createBaseDetailedBook();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.translatedTitle = object.translatedTitle ?? "";
    message.bookNumber = object.bookNumber ?? "";
    message.order = object.order ?? 0;
    message.collectionId = object.collectionId ?? "";
    message.introduction = object.introduction ?? "";
    message.chapters = object.chapters?.map((e) => SimpleChapter.fromPartial(e)) || [];
    message.numHadiths = object.numHadiths ?? 0;
    return message;
  },
};

function createBaseDetailedBookWithDetailedChapters(): DetailedBookWithDetailedChapters {
  return {
    id: "",
    title: "",
    translatedTitle: "",
    bookNumber: "",
    order: 0,
    collectionId: "",
    introduction: "",
    chapters: [],
    numHadiths: 0,
  };
}

export const DetailedBookWithDetailedChapters: MessageFns<DetailedBookWithDetailedChapters> = {
  encode(message: DetailedBookWithDetailedChapters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.translatedTitle !== "") {
      writer.uint32(26).string(message.translatedTitle);
    }
    if (message.bookNumber !== "") {
      writer.uint32(34).string(message.bookNumber);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    if (message.collectionId !== "") {
      writer.uint32(50).string(message.collectionId);
    }
    if (message.introduction !== "") {
      writer.uint32(58).string(message.introduction);
    }
    for (const v of message.chapters) {
      DetailedChapter.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.numHadiths !== 0) {
      writer.uint32(72).int32(message.numHadiths);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedBookWithDetailedChapters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedBookWithDetailedChapters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.translatedTitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bookNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.chapters.push(DetailedChapter.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.numHadiths = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedBookWithDetailedChapters {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      translatedTitle: isSet(object.translatedTitle) ? globalThis.String(object.translatedTitle) : "",
      bookNumber: isSet(object.bookNumber) ? globalThis.String(object.bookNumber) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      chapters: globalThis.Array.isArray(object?.chapters)
        ? object.chapters.map((e: any) => DetailedChapter.fromJSON(e))
        : [],
      numHadiths: isSet(object.numHadiths) ? globalThis.Number(object.numHadiths) : 0,
    };
  },

  toJSON(message: DetailedBookWithDetailedChapters): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.translatedTitle !== "") {
      obj.translatedTitle = message.translatedTitle;
    }
    if (message.bookNumber !== "") {
      obj.bookNumber = message.bookNumber;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    if (message.chapters?.length) {
      obj.chapters = message.chapters.map((e) => DetailedChapter.toJSON(e));
    }
    if (message.numHadiths !== 0) {
      obj.numHadiths = Math.round(message.numHadiths);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailedBookWithDetailedChapters>, I>>(
    base?: I,
  ): DetailedBookWithDetailedChapters {
    return DetailedBookWithDetailedChapters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailedBookWithDetailedChapters>, I>>(
    object: I,
  ): DetailedBookWithDetailedChapters {
    const message = createBaseDetailedBookWithDetailedChapters();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.translatedTitle = object.translatedTitle ?? "";
    message.bookNumber = object.bookNumber ?? "";
    message.order = object.order ?? 0;
    message.collectionId = object.collectionId ?? "";
    message.introduction = object.introduction ?? "";
    message.chapters = object.chapters?.map((e) => DetailedChapter.fromPartial(e)) || [];
    message.numHadiths = object.numHadiths ?? 0;
    return message;
  },
};

function createBaseDetailedChapter(): DetailedChapter {
  return {
    id: "",
    title: "",
    translatedTitle: "",
    chapterNumber: "",
    order: 0,
    book: undefined,
    collectionId: "",
    introduction: "",
    hadiths: [],
  };
}

export const DetailedChapter: MessageFns<DetailedChapter> = {
  encode(message: DetailedChapter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.translatedTitle !== "") {
      writer.uint32(26).string(message.translatedTitle);
    }
    if (message.chapterNumber !== "") {
      writer.uint32(34).string(message.chapterNumber);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    if (message.book !== undefined) {
      SimpleBook.encode(message.book, writer.uint32(50).fork()).join();
    }
    if (message.collectionId !== "") {
      writer.uint32(58).string(message.collectionId);
    }
    if (message.introduction !== "") {
      writer.uint32(66).string(message.introduction);
    }
    for (const v of message.hadiths) {
      SimpleHadith.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedChapter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedChapter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.translatedTitle = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chapterNumber = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.book = SimpleBook.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.introduction = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.hadiths.push(SimpleHadith.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedChapter {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      translatedTitle: isSet(object.translatedTitle) ? globalThis.String(object.translatedTitle) : "",
      chapterNumber: isSet(object.chapterNumber) ? globalThis.String(object.chapterNumber) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      book: isSet(object.book) ? SimpleBook.fromJSON(object.book) : undefined,
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      introduction: isSet(object.introduction) ? globalThis.String(object.introduction) : "",
      hadiths: globalThis.Array.isArray(object?.hadiths)
        ? object.hadiths.map((e: any) => SimpleHadith.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DetailedChapter): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.translatedTitle !== "") {
      obj.translatedTitle = message.translatedTitle;
    }
    if (message.chapterNumber !== "") {
      obj.chapterNumber = message.chapterNumber;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.book !== undefined) {
      obj.book = SimpleBook.toJSON(message.book);
    }
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.introduction !== "") {
      obj.introduction = message.introduction;
    }
    if (message.hadiths?.length) {
      obj.hadiths = message.hadiths.map((e) => SimpleHadith.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailedChapter>, I>>(base?: I): DetailedChapter {
    return DetailedChapter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailedChapter>, I>>(object: I): DetailedChapter {
    const message = createBaseDetailedChapter();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.translatedTitle = object.translatedTitle ?? "";
    message.chapterNumber = object.chapterNumber ?? "";
    message.order = object.order ?? 0;
    message.book = (object.book !== undefined && object.book !== null)
      ? SimpleBook.fromPartial(object.book)
      : undefined;
    message.collectionId = object.collectionId ?? "";
    message.introduction = object.introduction ?? "";
    message.hadiths = object.hadiths?.map((e) => SimpleHadith.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDetailedHadith(): DetailedHadith {
  return {
    id: "",
    hadithNumber: "",
    arabicText: "",
    translatedText: "",
    order: 0,
    references: [],
    gradings: [],
    chapter: undefined,
    book: undefined,
    collectionId: "",
    explanation: "",
  };
}

export const DetailedHadith: MessageFns<DetailedHadith> = {
  encode(message: DetailedHadith, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.hadithNumber !== "") {
      writer.uint32(18).string(message.hadithNumber);
    }
    if (message.arabicText !== "") {
      writer.uint32(26).string(message.arabicText);
    }
    if (message.translatedText !== "") {
      writer.uint32(34).string(message.translatedText);
    }
    if (message.order !== 0) {
      writer.uint32(40).int32(message.order);
    }
    for (const v of message.references) {
      HadithReferenceValue.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.gradings) {
      HadithGrading.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.chapter !== undefined) {
      SimpleChapter.encode(message.chapter, writer.uint32(66).fork()).join();
    }
    if (message.book !== undefined) {
      SimpleBook.encode(message.book, writer.uint32(74).fork()).join();
    }
    if (message.collectionId !== "") {
      writer.uint32(82).string(message.collectionId);
    }
    if (message.explanation !== "") {
      writer.uint32(90).string(message.explanation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetailedHadith {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailedHadith();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hadithNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.arabicText = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.translatedText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.order = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.references.push(HadithReferenceValue.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gradings.push(HadithGrading.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.chapter = SimpleChapter.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.book = SimpleBook.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetailedHadith {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      hadithNumber: isSet(object.hadithNumber) ? globalThis.String(object.hadithNumber) : "",
      arabicText: isSet(object.arabicText) ? globalThis.String(object.arabicText) : "",
      translatedText: isSet(object.translatedText) ? globalThis.String(object.translatedText) : "",
      order: isSet(object.order) ? globalThis.Number(object.order) : 0,
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => HadithReferenceValue.fromJSON(e))
        : [],
      gradings: globalThis.Array.isArray(object?.gradings)
        ? object.gradings.map((e: any) => HadithGrading.fromJSON(e))
        : [],
      chapter: isSet(object.chapter) ? SimpleChapter.fromJSON(object.chapter) : undefined,
      book: isSet(object.book) ? SimpleBook.fromJSON(object.book) : undefined,
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
    };
  },

  toJSON(message: DetailedHadith): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.hadithNumber !== "") {
      obj.hadithNumber = message.hadithNumber;
    }
    if (message.arabicText !== "") {
      obj.arabicText = message.arabicText;
    }
    if (message.translatedText !== "") {
      obj.translatedText = message.translatedText;
    }
    if (message.order !== 0) {
      obj.order = Math.round(message.order);
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => HadithReferenceValue.toJSON(e));
    }
    if (message.gradings?.length) {
      obj.gradings = message.gradings.map((e) => HadithGrading.toJSON(e));
    }
    if (message.chapter !== undefined) {
      obj.chapter = SimpleChapter.toJSON(message.chapter);
    }
    if (message.book !== undefined) {
      obj.book = SimpleBook.toJSON(message.book);
    }
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DetailedHadith>, I>>(base?: I): DetailedHadith {
    return DetailedHadith.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DetailedHadith>, I>>(object: I): DetailedHadith {
    const message = createBaseDetailedHadith();
    message.id = object.id ?? "";
    message.hadithNumber = object.hadithNumber ?? "";
    message.arabicText = object.arabicText ?? "";
    message.translatedText = object.translatedText ?? "";
    message.order = object.order ?? 0;
    message.references = object.references?.map((e) => HadithReferenceValue.fromPartial(e)) || [];
    message.gradings = object.gradings?.map((e) => HadithGrading.fromPartial(e)) || [];
    message.chapter = (object.chapter !== undefined && object.chapter !== null)
      ? SimpleChapter.fromPartial(object.chapter)
      : undefined;
    message.book = (object.book !== undefined && object.book !== null)
      ? SimpleBook.fromPartial(object.book)
      : undefined;
    message.collectionId = object.collectionId ?? "";
    message.explanation = object.explanation ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
